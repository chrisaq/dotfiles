#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.13"
# dependencies = ["rich>=13", "typer>=0.12"]
# ///
#:usage: cq_hypr_binds_free_v2
#:no-args: true
#:desc: Report used and free Hyprland keybinds (v2).
"""
Hyprland binds report

- Calls `hyprctl binds`, which prints blocks that start with `bind`
  followed by static key:value lines in fixed order.
- Parses those blocks deterministically.
- Reports:
  1) Used keys (with modifiers), dispatcher, arg, submap
  2) Submaps and their commands
  3) Free multimedia keys (no modifiers / with mainMod)
  4) Free *safe* Shift+key combos (no other modifiers)
     - Only function, navigation and media keys
  5) Free mainMod+key combos (no other modifiers)
  6) Free keys for each already-used mainMod+other-modifiers combo

Assumptions:
- US ANSI keyboard + common function/nav/media keys.
- `modmask` uses the X11-style bitmasks:
  Shift=1, Control=4, Alt(Mod1)=8, Super(Mod4)=64, etc.
  (So 0 => plain, 1 => Shift-only, 64 => Super, 65 => Shift+Super, ...)
"""

from __future__ import annotations

import os
import shutil
import subprocess
import sys
from dataclasses import dataclass
from typing import Dict, List, Tuple, Set

import typer
from rich.console import Console

app = typer.Typer(add_completion=False)
console = Console(stderr=True, highlight=False)

# Key handling

LETTERS = [chr(c) for c in range(ord("a"), ord("z") + 1)]
DIGITS = list("1234567890")
PUNCT = [
    "grave", "minus", "equal",
    "bracketleft", "bracketright", "backslash",
    "semicolon", "apostrophe",
    "comma", "period", "slash",
]
NAV_EDIT = [
    "escape", "tab", "backspace", "space", "return",
    "left", "right", "up", "down",
    "home", "end", "page_up", "page_down", "insert", "delete",
]
FUNCTIONS = [f"f{i}" for i in range(1, 25)]
MEDIA = [
    "print", "pause", "scroll_lock",
    "xf86audiolowervolume", "xf86audioraisevolume", "xf86audiomute",
    "xf86audioplay", "xf86audionext", "xf86audioprev", "xf86audiostop",
    "xf86monbrightnessup", "xf86monbrightnessdown",
    "xf86audiomicmute", "xf86calculator", "xf86sleep", "xf86display",
    "xf86wlan", "xf86bluetooth", "xf86tools", "xf86touchpadtoggle",
]

PLAIN_KEYS: List[str] = LETTERS + DIGITS + PUNCT + NAV_EDIT + FUNCTIONS + MEDIA
REGULAR_KEYS: List[str] = [k for k in PLAIN_KEYS if k not in MEDIA]

# "Safe" Shift-only candidates: function, navigation (no text keys), media
SHIFT_SAFE_NAV = [
    "left", "right", "up", "down",
    "home", "end", "page_up", "page_down", "insert", "delete",
]
SHIFT_SAFE_KEYS: List[str] = FUNCTIONS + SHIFT_SAFE_NAV + MEDIA

# Normalization for key names Hypr prints
NORMALIZE: Dict[str, str] = {
    "return": "return",
    "enter": "return",
    "esc": "escape",
    "escape": "escape",
    "space": "space",
    "pgup": "page_up",
    "page_up": "page_up",
    "pgdn": "page_down",
    "page_down": "page_down",
    "prtsc": "print",
    "print": "print",
    "ins": "insert",
    "insert": "insert",
    "del": "delete",
    "delete": "delete",
    "bksp": "backspace",
    "backspace": "backspace",
    "caps_lock": "caps_lock",
    "capslock": "caps_lock",
    "left": "left",
    "right": "right",
    "up": "up",
    "down": "down",
    "`": "grave",
    "-": "minus",
    "=": "equal",
    "[": "bracketleft",
    "]": "bracketright",
    "\\": "backslash",
    ";": "semicolon",
    "'": "apostrophe",
    ",": "comma",
    ".": "period",
    "/": "slash",
}
for i in range(1, 25):
    NORMALIZE[f"f{i}"] = f"f{i}"
for ch in LETTERS:
    NORMALIZE[ch] = ch
    NORMALIZE[ch.upper()] = ch
for d in DIGITS:
    NORMALIZE[d] = d


def norm_key(k: str) -> str:
    k = k.strip()
    if not k:
        return ""
    lk = k.lower()
    if lk.startswith("xf86"):
        return lk
    return NORMALIZE.get(k, NORMALIZE.get(lk, lk))


# Modmask decoding (X11-style)

MASKS = [
    (1, "SHIFT"),
    (2, "LOCK"),
    (4, "CTRL"),
    (8, "ALT"),
    (16, "MOD2"),
    (32, "MOD3"),
    (64, "SUPER"),
    (128, "MOD5"),
]


def mods_from_mask(mask: int) -> Tuple[str, ...]:
    mods = [name for bit, name in MASKS if mask & bit]
    return tuple(sorted(mods))


# Data model

@dataclass
class Bind:
    modmask: int
    submap: str
    key: str
    keycode: int
    catchall: bool
    description: str
    dispatcher: str
    arg: str
    raw: Dict[str, str]


# hyprctl

def run_hyprctl_binds(verbose: bool) -> str:
    if not shutil.which("hyprctl"):
        console.print("[red]Error: `hyprctl` not found in PATH.[/red]")
        raise typer.Exit(1)
    try:
        out = subprocess.check_output(
            ["hyprctl", "binds"],
            text=True,
            stderr=subprocess.STDOUT,
        )
        if verbose:
            console.rule("[dim]raw hyprctl binds[/dim]")
            console.print(out)
            console.rule()
        return out
    except subprocess.CalledProcessError as e:
        console.print("[red]Failed to run `hyprctl binds`[/red]")
        if e.output:
            console.print(e.output)
        raise typer.Exit(e.returncode or 1)


# Block parser

KV_KEYS_IN_ORDER = [
    "modmask",
    "submap",
    "key",
    "keycode",
    "catchall",
    "description",
    "dispatcher",
    "arg",
]


def parse_blocks(text: str, verbose: bool) -> List[Bind]:
    lines = text.splitlines()
    i = 0
    binds: List[Bind] = []

    def read_kv_block(start_index: int) -> Tuple[Dict[str, str], int]:
        data: Dict[str, str] = {}
        idx = start_index
        while idx < len(lines):
            line = lines[idx].strip("\n")
            if not line.strip():
                idx += 1
                continue
            if line.strip().startswith("bind"):
                break
            if ":" not in line:
                idx += 1
                continue
            k, v = line.split(":", 1)
            k = k.strip().lower()
            v = v.strip()
            if k in KV_KEYS_IN_ORDER:
                data[k] = v
            idx += 1
        return data, idx

    while i < len(lines):
        line = lines[i].strip()
        if line.startswith("bind"):
            i += 1
            kv, i = read_kv_block(i)

            if verbose:
                console.print("[cyan]parsed block[/cyan]", kv)

            modmask = int(kv.get("modmask", "0") or "0")
            submap = kv.get("submap", "").strip() or "global"
            key = norm_key(kv.get("key", ""))
            keycode = int(kv.get("keycode", "0") or "0")
            catchall = kv.get("catchall", "").lower() == "true"
            description = kv.get("description", "")
            dispatcher = kv.get("dispatcher", "")
            arg = kv.get("arg", "")

            binds.append(
                Bind(
                    modmask=modmask,
                    submap=submap,
                    key=key,
                    keycode=keycode,
                    catchall=catchall,
                    description=description,
                    dispatcher=dispatcher,
                    arg=arg,
                    raw=kv,
                )
            )
            continue

        i += 1

    binds = [b for b in binds if b.key]
    return binds


# Free keys / usage analysis

def analyze_keys(
    binds: List[Bind],
    main_mod_mask: int,
) -> Dict[str, object]:
    used_any: Set[str] = set()
    used_plain_no_mod: Set[str] = set()
    used_shift_only: Set[str] = set()
    used_main_only: Set[str] = set()
    used_by_combo: Dict[Tuple[str, ...], Set[str]] = {}

    for b in binds:
        if b.key not in PLAIN_KEYS:
            continue

        used_any.add(b.key)

        if b.modmask == 0:
            used_plain_no_mod.add(b.key)
        if b.modmask == 1:
            used_shift_only.add(b.key)
        if b.modmask == main_mod_mask:
            used_main_only.add(b.key)

        mods = mods_from_mask(b.modmask)
        used_by_combo.setdefault(mods, set()).add(b.key)

    main_mod_label = [name for bit, name in MASKS if bit == main_mod_mask]
    if main_mod_label:
        main_label = main_mod_label[0]
    else:
        main_label = f"MASK_{main_mod_mask}"

    combos_involving_main: Set[Tuple[str, ...]] = set()
    for combo in used_by_combo.keys():
        if main_label in combo and len(combo) > 1:
            combos_involving_main.add(combo)

    # regular keys unused anywhere (letters/digits/etc) â€” tracked but not printed
    free_regular_any: Set[str] = {k for k in REGULAR_KEYS if k not in used_any}

    free_media_plain: Set[str] = {k for k in MEDIA if k not in used_plain_no_mod}
    free_media_main: Set[str] = {k for k in MEDIA if k not in used_main_only}

    # "Safe" Shift-only keys: function, nav (non-text), media
    free_shift_safe: Set[str] = {k for k in SHIFT_SAFE_KEYS if k not in used_shift_only}

    free_main_only: Set[str] = {k for k in REGULAR_KEYS if k not in used_main_only}

    free_main_combos: Dict[Tuple[str, ...], Set[str]] = {}
    for combo in combos_involving_main:
        used_for_combo = used_by_combo.get(combo, set())
        free_for_combo = {k for k in REGULAR_KEYS if k not in used_for_combo}
        free_main_combos[combo] = free_for_combo

    return {
        "main_label": main_label,
        "free_regular_any": free_regular_any,
        "free_media_plain": free_media_plain,
        "free_media_main": free_media_main,
        "free_shift_safe": free_shift_safe,
        "free_main_only": free_main_only,
        "free_main_combos": free_main_combos,
    }


# Markdown rendering

def key_sort_key(k: str) -> Tuple[int, str]:
    if k in LETTERS:
        return (0, k)
    if k in DIGITS:
        return (1, k)
    return (2, k)


def render_markdown(binds: List[Bind], main_mod_mask: int) -> str:
    analysis = analyze_keys(binds, main_mod_mask)

    main_label: str = analysis["main_label"]                      # type: ignore[assignment]
    free_media_plain: Set[str] = analysis["free_media_plain"]    # type: ignore[assignment]
    free_media_main: Set[str] = analysis["free_media_main"]      # type: ignore[assignment]
    free_shift_safe: Set[str] = analysis["free_shift_safe"]      # type: ignore[assignment]
    free_main_only: Set[str] = analysis["free_main_only"]        # type: ignore[assignment]
    free_main_combos: Dict[Tuple[str, ...], Set[str]] = analysis["free_main_combos"]  # type: ignore[assignment]

    lines: List[str] = []
    lines.append("# Hyprland Binds Report\n")
    lines.append(
        "_Note: plain (no-modifier) regular keys and Shift+letter/digit/punct "
        "are treated as unsafe for WM binds and are not listed as \"free\"._\n"
    )

    # Used keys table
    lines.append("## Used keys and effects")
    lines.append("| Submap | Modifiers | Key | Dispatcher | Arg | Description | Modmask |")
    lines.append("|---|---|---|---|---|---:|---:|")
    for b in sorted(binds, key=lambda x: (x.submap.lower(), mods_from_mask(x.modmask), x.key)):
        mods = "+".join(mods_from_mask(b.modmask)) or "(none)"
        desc = b.description or ""
        lines.append(
            f"| `{b.submap}` | `{mods}` | `{b.key}` | `{b.dispatcher}` | `{b.arg}` | `{desc}` | `{b.modmask}` |"
        )

    # Submaps section
    lines.append("\n## Submaps")
    by_submap: Dict[str, List[Bind]] = {}
    for b in binds:
        by_submap.setdefault(b.submap, []).append(b)
    for name in sorted(by_submap.keys(), key=str.lower):
        lines.append(f"### `{name}`")
        lines.append("| Modifiers | Key | Dispatcher | Arg | Description |")
        lines.append("|---|---|---|---|---|")
        for b in sorted(by_submap[name], key=lambda b: (mods_from_mask(b.modmask), b.key)):
            mods = "+".join(mods_from_mask(b.modmask)) or "(none)"
            desc = b.description or ""
            lines.append(f"| `{mods}` | `{b.key}` | `{b.dispatcher}` | `{b.arg}` | `{desc}` |")
        lines.append("")

    # Multimedia keys
    lines.append("## Free multimedia keys")

    lines.append("### Without modifiers")
    if free_media_plain:
        lines.append("| Key |")
        lines.append("|---|")
        for k in sorted(free_media_plain, key=key_sort_key):
            lines.append(f"| `{k}` |")
    else:
        lines.append("_None_")

    lines.append(f"\n### With `{main_label}` only")
    if free_media_main:
        lines.append("| Modifiers | Key |")
        lines.append("|---|---|")
        for k in sorted(free_media_main, key=key_sort_key):
            lines.append(f"| `{main_label}` | `{k}` |")
    else:
        lines.append("_None_")

    # Free: *safe* Shift-only
    lines.append("\n## Free `Shift+key` combinations (safe keys only, no other modifiers)")
    if free_shift_safe:
        lines.append("| Modifiers | Key |")
        lines.append("|---|---|")
        for k in sorted(free_shift_safe, key=key_sort_key):
            lines.append(f"| `SHIFT` | `{k}` |")
    else:
        lines.append("_None_")

    # Free: mainMod only (regular keys)
    lines.append(f"\n## Free `{main_label}+key` combinations (no other modifiers)")
    if free_main_only:
        lines.append("| Modifiers | Key |")
        lines.append("|---|---|")
        for k in sorted(free_main_only, key=key_sort_key):
            lines.append(f"| `{main_label}` | `{k}` |")
    else:
        lines.append("_None_")

    # Free: mainMod + other modifiers
    lines.append(f"\n## Free `{main_label}+other` modifier combinations")
    if not free_main_combos:
        lines.append("_No other modifier combinations using mainMod were found._")
    else:
        for combo in sorted(free_main_combos.keys(), key=lambda c: (len(c), c)):
            keys = free_main_combos[combo]
            mods_label = "+".join(combo)
            lines.append(f"\n### Free `{mods_label}+key` combinations")
            if keys:
                lines.append("| Modifiers | Key |")
                lines.append("|---|---|")
                for k in sorted(keys, key=key_sort_key):
                    lines.append(f"| `{mods_label}` | `{k}` |")
            else:
                lines.append("_None_")

    lines.append("\n---\n*Generated from `hyprctl binds`*")
    lines.append(f"\nNice output: {os.path.basename(sys.argv[0])} | glow -p -w0")
    return "\n".join(lines)


@app.command()
def main(
    verbose: bool = typer.Option(
        False,
        "--verbose",
        "-v",
        help="Show raw output and parsed blocks on stderr.",
    ),
    main_mod_mask: int = typer.Option(
        64,
        "--main-mod-mask",
        "--mainmod-mask",
        help="Bitmask value for $mainMod (default: 64 = SUPER/Mod4).",
    ),
):
    text = run_hyprctl_binds(verbose=verbose)
    binds = parse_blocks(text, verbose=verbose)

    if verbose:
        console.rule("[dim]summary[/dim]")
        console.print(f"parsed binds: {len(binds)}")
        for b in binds[:5]:
            console.print(
                {
                    "submap": b.submap,
                    "key": b.key,
                    "modmask": b.modmask,
                    "dispatcher": b.dispatcher,
                    "arg": b.arg,
                }
            )

    md = render_markdown(binds, main_mod_mask=main_mod_mask)
    print(md)


if __name__ == "__main__":
    app()
